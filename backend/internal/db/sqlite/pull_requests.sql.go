// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pull_requests.sql

package sqlite

import (
	"context"
	"database/sql"
)

const deleteOrphanedPullRequests = `-- name: DeleteOrphanedPullRequests :execrows
DELETE FROM pull_requests
WHERE pull_requests.user_id = ?
  AND pull_requests.id NOT IN (
    SELECT DISTINCT notifications.pull_request_id 
    FROM notifications
    WHERE notifications.user_id = ?
      AND notifications.pull_request_id IS NOT NULL
)
`

type DeleteOrphanedPullRequestsParams struct {
	UserID   string
	UserID_2 string
}

// Delete pull_requests that have no associated notifications for a user
// Note: user_id passed twice - once for outer query, once for subquery
func (q *Queries) DeleteOrphanedPullRequests(ctx context.Context, arg DeleteOrphanedPullRequestsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOrphanedPullRequests, arg.UserID, arg.UserID_2)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertPullRequest = `-- name: UpsertPullRequest :one
INSERT INTO pull_requests (
    user_id, repository_id, github_id, node_id, number, title, state,
    draft, merged, author_login, author_id,
    created_at, updated_at, closed_at, merged_at, raw
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(user_id, repository_id, number) DO UPDATE SET
    github_id = excluded.github_id,
    node_id = excluded.node_id,
    title = excluded.title,
    state = excluded.state,
    draft = excluded.draft,
    merged = excluded.merged,
    author_login = excluded.author_login,
    author_id = excluded.author_id,
    updated_at = excluded.updated_at,
    closed_at = excluded.closed_at,
    merged_at = excluded.merged_at,
    raw = excluded.raw
RETURNING id, user_id, repository_id, github_id, node_id, number, title, state, draft, merged, author_login, author_id, created_at, updated_at, closed_at, merged_at, raw
`

type UpsertPullRequestParams struct {
	UserID       string
	RepositoryID int64
	GithubID     sql.NullInt64
	NodeID       sql.NullString
	Number       int64
	Title        sql.NullString
	State        sql.NullString
	Draft        sql.NullInt64
	Merged       sql.NullInt64
	AuthorLogin  sql.NullString
	AuthorID     sql.NullInt64
	CreatedAt    sql.NullString
	UpdatedAt    sql.NullString
	ClosedAt     sql.NullString
	MergedAt     sql.NullString
	Raw          sql.NullString
}

func (q *Queries) UpsertPullRequest(ctx context.Context, arg UpsertPullRequestParams) (PullRequest, error) {
	row := q.db.QueryRowContext(ctx, upsertPullRequest,
		arg.UserID,
		arg.RepositoryID,
		arg.GithubID,
		arg.NodeID,
		arg.Number,
		arg.Title,
		arg.State,
		arg.Draft,
		arg.Merged,
		arg.AuthorLogin,
		arg.AuthorID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ClosedAt,
		arg.MergedAt,
		arg.Raw,
	)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RepositoryID,
		&i.GithubID,
		&i.NodeID,
		&i.Number,
		&i.Title,
		&i.State,
		&i.Draft,
		&i.Merged,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.MergedAt,
		&i.Raw,
	)
	return i, err
}
