// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package sqlite

import (
	"context"
	"database/sql"
)

const ackJob = `-- name: AckJob :exec
DELETE FROM jobs WHERE id = ?
`

// Mark job as completed and delete it
func (q *Queries) AckJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, ackJob, id)
	return err
}

const countPendingByQueue = `-- name: CountPendingByQueue :one
SELECT COUNT(*) as count FROM jobs
WHERE queue = ? AND status = 'pending'
`

// Count pending jobs in a specific queue
func (q *Queries) CountPendingByQueue(ctx context.Context, queue string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingByQueue, queue)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldCompletedJobs = `-- name: DeleteOldCompletedJobs :execrows
DELETE FROM jobs
WHERE status = 'completed'
  AND completed_at < ?
`

// Cleanup old completed jobs (if we ever keep them instead of deleting on ack)
func (q *Queries) DeleteOldCompletedJobs(ctx context.Context, completedAt sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOldCompletedJobs, completedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteOldFailedJobs = `-- name: DeleteOldFailedJobs :execrows
DELETE FROM jobs
WHERE status = 'failed'
  AND completed_at < ?
`

// Cleanup old failed jobs after retention period
func (q *Queries) DeleteOldFailedJobs(ctx context.Context, completedAt sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOldFailedJobs, completedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const dequeueJob = `-- name: DequeueJob :one
UPDATE jobs
SET status = 'processing',
    started_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now'),
    attempts = attempts + 1,
    updated_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
WHERE id = (
    SELECT j.id FROM jobs j
    WHERE j.queue = ?
      AND j.status = 'pending'
      AND j.scheduled_at <= strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
    ORDER BY j.scheduled_at ASC
    LIMIT 1
)
RETURNING id, queue, payload, status, attempts, max_attempts, created_at, updated_at, scheduled_at, started_at, completed_at, last_error
`

// Atomically claim the next available job from a queue
// Uses a subquery to find the job, then UPDATE with RETURNING to claim it
func (q *Queries) DequeueJob(ctx context.Context, queue string) (Job, error) {
	row := q.db.QueryRowContext(ctx, dequeueJob, queue)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Queue,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
	)
	return i, err
}

const enqueueJob = `-- name: EnqueueJob :one
INSERT INTO jobs (queue, payload, max_attempts, scheduled_at, created_at, updated_at)
VALUES (?, ?, ?, ?, strftime('%Y-%m-%dT%H:%M:%SZ', 'now'), strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
RETURNING id, queue, payload, status, attempts, max_attempts, created_at, updated_at, scheduled_at, started_at, completed_at, last_error
`

type EnqueueJobParams struct {
	Queue       string
	Payload     string
	MaxAttempts int64
	ScheduledAt string
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, enqueueJob,
		arg.Queue,
		arg.Payload,
		arg.MaxAttempts,
		arg.ScheduledAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Queue,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
	)
	return i, err
}

const getAllQueueStats = `-- name: GetAllQueueStats :one
SELECT
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count
FROM jobs
`

type GetAllQueueStatsRow struct {
	PendingCount    int64
	ProcessingCount int64
	FailedCount     int64
}

// Get overall statistics
func (q *Queries) GetAllQueueStats(ctx context.Context) (GetAllQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAllQueueStats)
	var i GetAllQueueStatsRow
	err := row.Scan(&i.PendingCount, &i.ProcessingCount, &i.FailedCount)
	return i, err
}

const getJob = `-- name: GetJob :one
SELECT id, queue, payload, status, attempts, max_attempts, created_at, updated_at, scheduled_at, started_at, completed_at, last_error FROM jobs WHERE id = ?
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Queue,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
	)
	return i, err
}

const getQueueStats = `-- name: GetQueueStats :one
SELECT
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count
FROM jobs
WHERE queue = ?
`

type GetQueueStatsRow struct {
	PendingCount    int64
	ProcessingCount int64
	FailedCount     int64
}

// Get statistics for observability
func (q *Queries) GetQueueStats(ctx context.Context, queue string) (GetQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getQueueStats, queue)
	var i GetQueueStatsRow
	err := row.Scan(&i.PendingCount, &i.ProcessingCount, &i.FailedCount)
	return i, err
}

const listFailedJobs = `-- name: ListFailedJobs :many
SELECT id, queue, payload, status, attempts, max_attempts, created_at, updated_at, scheduled_at, started_at, completed_at, last_error FROM jobs
WHERE queue = ? AND status = 'failed'
ORDER BY updated_at DESC
LIMIT ?
`

type ListFailedJobsParams struct {
	Queue string
	Limit int64
}

// List failed jobs for debugging/retry
func (q *Queries) ListFailedJobs(ctx context.Context, arg ListFailedJobsParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, listFailedJobs, arg.Queue, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Queue,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nackJobFailed = `-- name: NackJobFailed :exec
UPDATE jobs
SET status = 'failed',
    last_error = ?,
    completed_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now'),
    updated_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
WHERE id = ?
`

type NackJobFailedParams struct {
	LastError sql.NullString
	ID        int64
}

// Mark job as permanently failed (dead letter)
func (q *Queries) NackJobFailed(ctx context.Context, arg NackJobFailedParams) error {
	_, err := q.db.ExecContext(ctx, nackJobFailed, arg.LastError, arg.ID)
	return err
}

const nackJobRetry = `-- name: NackJobRetry :exec
UPDATE jobs
SET status = 'pending',
    started_at = NULL,
    scheduled_at = ?,
    last_error = ?,
    updated_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
WHERE id = ?
`

type NackJobRetryParams struct {
	ScheduledAt string
	LastError   sql.NullString
	ID          int64
}

// Mark job for retry with exponential backoff
// scheduled_at is passed as parameter (calculated in Go)
func (q *Queries) NackJobRetry(ctx context.Context, arg NackJobRetryParams) error {
	_, err := q.db.ExecContext(ctx, nackJobRetry, arg.ScheduledAt, arg.LastError, arg.ID)
	return err
}

const resetStaleJobs = `-- name: ResetStaleJobs :execrows
UPDATE jobs
SET status = 'pending',
    started_at = NULL,
    updated_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
WHERE status = 'processing'
  AND started_at < ?
`

// Reset jobs that have been processing for too long (crashed workers)
// cutoff_time is passed as parameter
func (q *Queries) ResetStaleJobs(ctx context.Context, startedAt sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetStaleJobs, startedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const retryFailedJob = `-- name: RetryFailedJob :exec
UPDATE jobs
SET status = 'pending',
    attempts = 0,
    scheduled_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now'),
    last_error = NULL,
    completed_at = NULL,
    updated_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
WHERE id = ? AND status = 'failed'
`

// Manually retry a failed job
func (q *Queries) RetryFailedJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, retryFailedJob, id)
	return err
}
