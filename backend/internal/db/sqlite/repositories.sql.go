// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repositories.sql

package sqlite

import (
	"context"
	"database/sql"
)

const getRepositoryByID = `-- name: GetRepositoryByID :one
SELECT id, user_id, github_id, node_id, name, full_name, owner_login, owner_id, private, description, html_url, fork, visibility, default_branch, archived, disabled, pushed_at, created_at, updated_at, raw, owner_avatar_url, owner_html_url FROM repositories WHERE user_id = ? AND id = ?
`

type GetRepositoryByIDParams struct {
	UserID string
	ID     int64
}

func (q *Queries) GetRepositoryByID(ctx context.Context, arg GetRepositoryByIDParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, getRepositoryByID, arg.UserID, arg.ID)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.NodeID,
		&i.Name,
		&i.FullName,
		&i.OwnerLogin,
		&i.OwnerID,
		&i.Private,
		&i.Description,
		&i.HtmlUrl,
		&i.Fork,
		&i.Visibility,
		&i.DefaultBranch,
		&i.Archived,
		&i.Disabled,
		&i.PushedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Raw,
		&i.OwnerAvatarUrl,
		&i.OwnerHtmlUrl,
	)
	return i, err
}

const listRepositories = `-- name: ListRepositories :many
SELECT id, user_id, github_id, node_id, name, full_name, owner_login, owner_id, private, description, html_url, fork, visibility, default_branch, archived, disabled, pushed_at, created_at, updated_at, raw, owner_avatar_url, owner_html_url FROM repositories WHERE user_id = ? ORDER BY full_name
`

func (q *Queries) ListRepositories(ctx context.Context, userID string) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, listRepositories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GithubID,
			&i.NodeID,
			&i.Name,
			&i.FullName,
			&i.OwnerLogin,
			&i.OwnerID,
			&i.Private,
			&i.Description,
			&i.HtmlUrl,
			&i.Fork,
			&i.Visibility,
			&i.DefaultBranch,
			&i.Archived,
			&i.Disabled,
			&i.PushedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Raw,
			&i.OwnerAvatarUrl,
			&i.OwnerHtmlUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRepository = `-- name: UpsertRepository :one
INSERT INTO repositories (
    user_id, github_id, node_id, name, full_name, owner_login, owner_id,
    private, description, html_url, fork, visibility, default_branch,
    archived, disabled, pushed_at, created_at, updated_at, raw,
    owner_avatar_url, owner_html_url
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(user_id, full_name) DO UPDATE SET
    github_id = excluded.github_id,
    node_id = excluded.node_id,
    name = excluded.name,
    owner_login = excluded.owner_login,
    owner_id = excluded.owner_id,
    private = excluded.private,
    description = excluded.description,
    html_url = excluded.html_url,
    fork = excluded.fork,
    visibility = excluded.visibility,
    default_branch = excluded.default_branch,
    archived = excluded.archived,
    disabled = excluded.disabled,
    pushed_at = excluded.pushed_at,
    updated_at = excluded.updated_at,
    raw = excluded.raw,
    owner_avatar_url = excluded.owner_avatar_url,
    owner_html_url = excluded.owner_html_url
RETURNING id, user_id, github_id, node_id, name, full_name, owner_login, owner_id, private, description, html_url, fork, visibility, default_branch, archived, disabled, pushed_at, created_at, updated_at, raw, owner_avatar_url, owner_html_url
`

type UpsertRepositoryParams struct {
	UserID         string
	GithubID       sql.NullInt64
	NodeID         sql.NullString
	Name           string
	FullName       string
	OwnerLogin     sql.NullString
	OwnerID        sql.NullInt64
	Private        sql.NullInt64
	Description    sql.NullString
	HtmlUrl        sql.NullString
	Fork           sql.NullInt64
	Visibility     sql.NullString
	DefaultBranch  sql.NullString
	Archived       sql.NullInt64
	Disabled       sql.NullInt64
	PushedAt       sql.NullString
	CreatedAt      sql.NullString
	UpdatedAt      sql.NullString
	Raw            sql.NullString
	OwnerAvatarUrl sql.NullString
	OwnerHtmlUrl   sql.NullString
}

func (q *Queries) UpsertRepository(ctx context.Context, arg UpsertRepositoryParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, upsertRepository,
		arg.UserID,
		arg.GithubID,
		arg.NodeID,
		arg.Name,
		arg.FullName,
		arg.OwnerLogin,
		arg.OwnerID,
		arg.Private,
		arg.Description,
		arg.HtmlUrl,
		arg.Fork,
		arg.Visibility,
		arg.DefaultBranch,
		arg.Archived,
		arg.Disabled,
		arg.PushedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Raw,
		arg.OwnerAvatarUrl,
		arg.OwnerHtmlUrl,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.NodeID,
		&i.Name,
		&i.FullName,
		&i.OwnerLogin,
		&i.OwnerID,
		&i.Private,
		&i.Description,
		&i.HtmlUrl,
		&i.Fork,
		&i.Visibility,
		&i.DefaultBranch,
		&i.Archived,
		&i.Disabled,
		&i.PushedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Raw,
		&i.OwnerAvatarUrl,
		&i.OwnerHtmlUrl,
	)
	return i, err
}
