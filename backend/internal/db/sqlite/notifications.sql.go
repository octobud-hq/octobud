// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package sqlite

import (
	"context"
	"database/sql"
)

const archiveNotification = `-- name: ArchiveNotification :one
UPDATE notifications 
SET archived = 1,
    snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type ArchiveNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) ArchiveNotification(ctx context.Context, arg ArchiveNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, archiveNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const countEligibleForCleanup = `-- name: CountEligibleForCleanup :one
SELECT COUNT(*) as count
FROM notifications n
WHERE n.user_id = ?
  AND (n.archived = 1 OR n.muted = 1)
  AND (?2 = 0 OR n.starred = 0)
  AND (?3 = 0 OR n.id NOT IN (
      SELECT ta.entity_id FROM tag_assignments ta WHERE ta.user_id = n.user_id AND ta.entity_type = 'notification'
  ))
  AND COALESCE(n.effective_sort_date, n.github_updated_at, n.imported_at) < ?4
`

type CountEligibleForCleanupParams struct {
	UserID         string
	ProtectStarred interface{}
	ProtectTagged  interface{}
	CutoffDate     string
}

// Count notifications eligible for cleanup based on retention settings
// Eligible: (archived OR muted), not starred (if protected), not tagged (if protected)
// Uses effective_sort_date for cutoff (consistent with UI sorting, handles snoozed items naturally)
func (q *Queries) CountEligibleForCleanup(ctx context.Context, arg CountEligibleForCleanupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEligibleForCleanup,
		arg.UserID,
		arg.ProtectStarred,
		arg.ProtectTagged,
		arg.CutoffDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldArchivedNotifications = `-- name: DeleteOldArchivedNotifications :execrows
DELETE FROM notifications
WHERE id IN (
    SELECT n.id FROM notifications n
    WHERE n.user_id = ?
      AND (n.archived = 1 OR n.muted = 1)
      AND (?2 = 0 OR n.starred = 0)
      AND (?3 = 0 OR n.id NOT IN (
          SELECT ta.entity_id FROM tag_assignments ta WHERE ta.user_id = n.user_id AND ta.entity_type = 'notification'
      ))
      AND COALESCE(n.effective_sort_date, n.github_updated_at, n.imported_at) < ?4
    ORDER BY COALESCE(n.effective_sort_date, n.github_updated_at, n.imported_at) ASC
    LIMIT ?5
)
`

type DeleteOldArchivedNotificationsParams struct {
	UserID         string
	ProtectStarred interface{}
	ProtectTagged  interface{}
	CutoffDate     string
	BatchSize      int64
}

// Delete old archived/muted notifications in batches, respecting protection settings
// Uses effective_sort_date for cutoff (consistent with UI sorting, handles snoozed items naturally)
// Returns number of deleted rows
func (q *Queries) DeleteOldArchivedNotifications(ctx context.Context, arg DeleteOldArchivedNotificationsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOldArchivedNotifications,
		arg.UserID,
		arg.ProtectStarred,
		arg.ProtectTagged,
		arg.CutoffDate,
		arg.BatchSize,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getNotificationByGithubID = `-- name: GetNotificationByGithubID :one
SELECT id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason FROM notifications WHERE user_id = ? AND github_id = ?
`

type GetNotificationByGithubIDParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) GetNotificationByGithubID(ctx context.Context, arg GetNotificationByGithubIDParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByGithubID, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason FROM notifications WHERE user_id = ? AND id = ?
`

type GetNotificationByIDParams struct {
	UserID string
	ID     int64
}

func (q *Queries) GetNotificationByID(ctx context.Context, arg GetNotificationByIDParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID, arg.UserID, arg.ID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const getStorageStats = `-- name: GetStorageStats :one
SELECT
    COUNT(*) as total_count,
    COUNT(CASE WHEN archived = 1 THEN 1 END) as archived_count,
    COUNT(CASE WHEN starred = 1 THEN 1 END) as starred_count,
    COUNT(CASE WHEN snoozed_until IS NOT NULL THEN 1 END) as snoozed_count,
    COUNT(CASE WHEN is_read = 0 THEN 1 END) as unread_count,
    (SELECT COUNT(DISTINCT ta.entity_id) FROM tag_assignments ta WHERE ta.user_id = ? AND ta.entity_type = 'notification') as tagged_count
FROM notifications n
WHERE n.user_id = ?
`

type GetStorageStatsParams struct {
	UserID   string
	UserID_2 string
}

type GetStorageStatsRow struct {
	TotalCount    int64
	ArchivedCount int64
	StarredCount  int64
	SnoozedCount  int64
	UnreadCount   int64
	TaggedCount   int64
}

// Get notification counts by state for storage management UI
func (q *Queries) GetStorageStats(ctx context.Context, arg GetStorageStatsParams) (GetStorageStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStorageStats, arg.UserID, arg.UserID_2)
	var i GetStorageStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.ArchivedCount,
		&i.StarredCount,
		&i.SnoozedCount,
		&i.UnreadCount,
		&i.TaggedCount,
	)
	return i, err
}

const markNotificationFiltered = `-- name: MarkNotificationFiltered :one
UPDATE notifications SET filtered = 1 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type MarkNotificationFilteredParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) MarkNotificationFiltered(ctx context.Context, arg MarkNotificationFilteredParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationFiltered, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const markNotificationRead = `-- name: MarkNotificationRead :one
UPDATE notifications SET is_read = 1 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type MarkNotificationReadParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) MarkNotificationRead(ctx context.Context, arg MarkNotificationReadParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationRead, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const markNotificationUnfiltered = `-- name: MarkNotificationUnfiltered :one
UPDATE notifications SET filtered = 0 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type MarkNotificationUnfilteredParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) MarkNotificationUnfiltered(ctx context.Context, arg MarkNotificationUnfilteredParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationUnfiltered, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const markNotificationUnread = `-- name: MarkNotificationUnread :one
UPDATE notifications SET is_read = 0 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type MarkNotificationUnreadParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) MarkNotificationUnread(ctx context.Context, arg MarkNotificationUnreadParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationUnread, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const muteNotification = `-- name: MuteNotification :one
UPDATE notifications 
SET muted = 1,
    snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type MuteNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) MuteNotification(ctx context.Context, arg MuteNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, muteNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const resetNotificationStatusOnSync = `-- name: ResetNotificationStatusOnSync :exec
UPDATE notifications 
SET archived = 0, is_read = 0 
WHERE user_id = ? AND github_id = ?
`

type ResetNotificationStatusOnSyncParams struct {
	UserID   string
	GithubID string
}

// Used by UpsertNotification to implement smart status updates.
// When new activity is detected (github_updated_at changed) and notification is not muted,
// reset archived and is_read to bring the notification back to inbox.
func (q *Queries) ResetNotificationStatusOnSync(ctx context.Context, arg ResetNotificationStatusOnSyncParams) error {
	_, err := q.db.ExecContext(ctx, resetNotificationStatusOnSync, arg.UserID, arg.GithubID)
	return err
}

const snoozeNotification = `-- name: SnoozeNotification :one
UPDATE notifications 
SET snoozed_until = ?,
    snoozed_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now'),
    effective_sort_date = ?
WHERE user_id = ? AND github_id = ? 
RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type SnoozeNotificationParams struct {
	SnoozedUntil      sql.NullString
	EffectiveSortDate string
	UserID            string
	GithubID          string
}

func (q *Queries) SnoozeNotification(ctx context.Context, arg SnoozeNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, snoozeNotification,
		arg.SnoozedUntil,
		arg.EffectiveSortDate,
		arg.UserID,
		arg.GithubID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const starNotification = `-- name: StarNotification :one
UPDATE notifications SET starred = 1 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type StarNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) StarNotification(ctx context.Context, arg StarNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, starNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unarchiveNotification = `-- name: UnarchiveNotification :one
UPDATE notifications SET archived = 0 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type UnarchiveNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) UnarchiveNotification(ctx context.Context, arg UnarchiveNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unarchiveNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unmuteNotification = `-- name: UnmuteNotification :one
UPDATE notifications SET muted = 0 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type UnmuteNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) UnmuteNotification(ctx context.Context, arg UnmuteNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unmuteNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unsnoozeNotification = `-- name: UnsnoozeNotification :one
UPDATE notifications 
SET snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE user_id = ? AND github_id = ? 
RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type UnsnoozeNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) UnsnoozeNotification(ctx context.Context, arg UnsnoozeNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unsnoozeNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unstarNotification = `-- name: UnstarNotification :one
UPDATE notifications SET starred = 0 WHERE user_id = ? AND github_id = ? RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type UnstarNotificationParams struct {
	UserID   string
	GithubID string
}

func (q *Queries) UnstarNotification(ctx context.Context, arg UnstarNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unstarNotification, arg.UserID, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const updateNotificationSubject = `-- name: UpdateNotificationSubject :exec
UPDATE notifications SET
    subject_raw = ?,
    subject_fetched_at = ?,
    pull_request_id = ?,
    subject_number = ?,
    subject_state = ?,
    subject_merged = ?,
    subject_state_reason = ?
WHERE user_id = ? AND github_id = ?
`

type UpdateNotificationSubjectParams struct {
	SubjectRaw         sql.NullString
	SubjectFetchedAt   sql.NullString
	PullRequestID      sql.NullInt64
	SubjectNumber      sql.NullInt64
	SubjectState       sql.NullString
	SubjectMerged      sql.NullInt64
	SubjectStateReason sql.NullString
	UserID             string
	GithubID           string
}

func (q *Queries) UpdateNotificationSubject(ctx context.Context, arg UpdateNotificationSubjectParams) error {
	_, err := q.db.ExecContext(ctx, updateNotificationSubject,
		arg.SubjectRaw,
		arg.SubjectFetchedAt,
		arg.PullRequestID,
		arg.SubjectNumber,
		arg.SubjectState,
		arg.SubjectMerged,
		arg.SubjectStateReason,
		arg.UserID,
		arg.GithubID,
	)
	return err
}

const upsertNotification = `-- name: UpsertNotification :one
INSERT INTO notifications (
    user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url,
    subject_latest_comment_url, reason, github_unread, github_updated_at,
    github_last_read_at, github_url, github_subscription_url, payload,
    subject_raw, subject_fetched_at, author_login, author_id,
    subject_number, subject_state, subject_merged, subject_state_reason,
    imported_at, effective_sort_date
) VALUES (
    ?1,
    ?2, 
    ?3, 
    ?4,
    ?5, 
    ?6, 
    ?7,
    ?8, 
    ?9, 
    ?10, 
    ?11,
    ?12, 
    ?13, 
    ?14, 
    ?15,
    ?16,
    ?17,
    ?18,
    ?19,
    ?20,
    ?21,
    ?22,
    ?23,
    strftime('%Y-%m-%dT%H:%M:%SZ', 'now'), 
    COALESCE(?24, strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
)
ON CONFLICT(user_id, github_id) DO UPDATE SET
    pull_request_id = excluded.pull_request_id,
    subject_title = excluded.subject_title,
    subject_url = excluded.subject_url,
    subject_latest_comment_url = excluded.subject_latest_comment_url,
    reason = excluded.reason,
    github_unread = excluded.github_unread,
    github_updated_at = excluded.github_updated_at,
    github_last_read_at = excluded.github_last_read_at,
    github_url = excluded.github_url,
    github_subscription_url = excluded.github_subscription_url,
    payload = excluded.payload,
    subject_raw = excluded.subject_raw,
    subject_fetched_at = excluded.subject_fetched_at,
    author_login = excluded.author_login,
    author_id = excluded.author_id,
    subject_number = excluded.subject_number,
    subject_state = excluded.subject_state,
    subject_merged = excluded.subject_merged,
    subject_state_reason = excluded.subject_state_reason,
    -- Preserve snoozed_until as sort date if notification is snoozed, otherwise use new github_updated_at
    effective_sort_date = COALESCE(notifications.snoozed_until, excluded.effective_sort_date)
RETURNING id, user_id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, subject_number, subject_state, subject_merged, subject_state_reason
`

type UpsertNotificationParams struct {
	UserID                  string
	GithubID                string
	RepositoryID            int64
	PullRequestID           sql.NullInt64
	SubjectType             string
	SubjectTitle            string
	SubjectUrl              sql.NullString
	SubjectLatestCommentUrl sql.NullString
	Reason                  sql.NullString
	GithubUnread            sql.NullInt64
	GithubUpdatedAt         sql.NullString
	GithubLastReadAt        sql.NullString
	GithubUrl               sql.NullString
	GithubSubscriptionUrl   sql.NullString
	Payload                 sql.NullString
	SubjectRaw              sql.NullString
	SubjectFetchedAt        sql.NullString
	AuthorLogin             sql.NullString
	AuthorID                sql.NullInt64
	SubjectNumber           sql.NullInt64
	SubjectState            sql.NullString
	SubjectMerged           sql.NullInt64
	SubjectStateReason      sql.NullString
	EffectiveSortDate       interface{}
}

func (q *Queries) UpsertNotification(ctx context.Context, arg UpsertNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, upsertNotification,
		arg.UserID,
		arg.GithubID,
		arg.RepositoryID,
		arg.PullRequestID,
		arg.SubjectType,
		arg.SubjectTitle,
		arg.SubjectUrl,
		arg.SubjectLatestCommentUrl,
		arg.Reason,
		arg.GithubUnread,
		arg.GithubUpdatedAt,
		arg.GithubLastReadAt,
		arg.GithubUrl,
		arg.GithubSubscriptionUrl,
		arg.Payload,
		arg.SubjectRaw,
		arg.SubjectFetchedAt,
		arg.AuthorLogin,
		arg.AuthorID,
		arg.SubjectNumber,
		arg.SubjectState,
		arg.SubjectMerged,
		arg.SubjectStateReason,
		arg.EffectiveSortDate,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}
